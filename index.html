<meta charset="utf-8" />
<link rel="icon" href="data:,">
<style>
  /* Prism - Raw theme */
  pre { overflow: auto;margin: .5em 0;padding: 1em; }
  pre, code[class*="language-"] { color: #ccc;background: #111;border-radius: .3em;font: 400 1em/1.5 Menlo, monospace;white-space: pre;tab-size: 2;hyphens: none; }
  :not(pre) > code[class*="language-"] { padding: .1em; }
  .token.comment { color: #555; }
  .token.class-name { color: #fd0; }
  .token.keyword { color: #f6e; }
  .token.property-access { color: #f34; }
  .token.boolean, .token.number { color: #fa3; }
  .token.string, .token.regex { color: #7d0; }
  .token.function, .token.method { color: #39f; }
  .token.operator { color: #3df; }
  [id] { cursor: pointer; }
  [id]:hover { background: linear-gradient(to right,#03f,#0bf);-webkit-background-clip: text;-webkit-text-fill-color: transparent; }
</style>
<style>
  * { outline: inherit;font: inherit;-moz-osx-font-smoothing: grayscale;-webkit-font-smoothing: antialiased;-webkit-tap-highlight-color: transparent;-webkit-text-size-adjust: 100%;box-sizing: border-box;caret-color: var(--primary); }
  body { margin: 80px;color: white;background: #2f3138;font-family: sans-serif;font-size: 18px; }
  h1 { display: flex;align-items: center;justify-content: space-between;color: #afafaf;font-size: 22px;font-weight: 300;text-transform: uppercase;letter-spacing: 0.1em; }
  button { opacity: 0.8;padding: 5px 10px;color: #fa3;background: none;border: 1px solid #fa3;border-radius: 4px;font-size: 18px;text-transform: uppercase; }
  button:hover { opacity: 1; }
  pre { margin: 0;padding: 0;background: none; }
  pre.error,
  pre.warning { padding: 10px;white-space: normal; }
  pre.error { color: #f34; }
  .testarea { margin-top: 15px;transition: 0.4s; }
  .testarea.success { background: #2f4138!important; }
  .testarea.warning { background: #4f4138!important; }
  .testarea.error { background: #4f3138!important; }
  .testarea svg { position: absolute;top: calc(50% - 17px);right: 0;cursor: pointer;margin: 5px 10px;border: none;fill: #fa3; }
  .testarea .time { position: absolute;top: calc(50% - 17px);right: 40px;line-height: 34px; }
  [v-cloak] { display: none; }

  .testarea { position: relative;overflow: hidden;width: 100%;color: white;background-color: #2a2b2f;border-radius: 10px;font-family: source-code-pro, Menlo, Monaco, Consolas, "Courier New";line-height: 27px; }
  .testarea textarea { position: absolute;top: 0px;left: 0px;overflow: hidden;width: 100%;height: 100%;padding: 20px;color: inherit;background: none;border: none;outline: none;white-space: pre-wrap;-webkit-font-smoothing: antialiased;-webkit-text-fill-color: transparent;resize: none; }
  .testarea pre { position: relative;pointer-events: none;margin: 0px;padding: 20px;background: none;border: 0px;white-space: pre-wrap; }
</style>
<main v-cloak>
  <h1>Setup Code</h1>
  <testarea v-model="setup"></testarea>
  <h1>Test Cases<button @click="tests = [['', null]].concat(tests)">Add Case</button></h1>
  <testarea :value="test[0]" :expect="test[1]" :setup="setup" @input="Vue.set(tests[i], 0, $event)" @expect="Vue.set(tests[i], 1, $event)" @clear="tests = tests.filter((d, di) => di !== i)" v-for="test, i in tests"></testarea>
</main>
<script src="https://unpkg.com/vue@2.6.10/dist/vue.min.js"></script>
<script src="https://unpkg.com/prismjs@1.16.0/prism.js"></script>
<script src="https://unpkg.com/prismjs@1.16.0/components/prism-markdown.js"></script>
<script src="https://unpkg.com/prismjs@1.16.0/components/prism-js-extras.js"></script>
<script>
  Vue.component('testarea', {
    props: ['value', 'expect', 'setup'],
    template: `<div class="test">
      <div style="display: flex;">
        <div class="testarea">
          <textarea :value="value" @input="$emit('input', $event.target.value)"></textarea>
          <pre v-html="Prism.highlight(value || '', Prism.languages.js, 'js')"></pre>
        </div>
        <div v-if="$listeners.expect" class="testarea" :class="output">
          <textarea :value="JSON.stringify(expect || null, true, 2).replace(/\\s+/g, ' ')" @input="tryparse"></textarea>
          <pre v-html="Prism.highlight(JSON.stringify(expect || null, true, 2).replace(/\\s+/g, ' '), Prism.languages.js, 'js')"></pre>
          <svg @click="$emit('clear')" v-if="$listeners.clear" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg>
          <div class="time" v-if="output.time">{{ output.time < 1 ? ~~(output.time * 1000) + 'Î¼s' : output.time < 1000 ? ~~output.time + 'ms' : ~~(output.time / 1000) + 's' }}</div>
        </div>
      </div>
      <div style="display: flex;">
        <pre class="error" v-if="output.error">{{ output.error }}</pre>
        <pre class="warning" v-if="output.warning" v-html="output.warning"></pre>
      </div>
    </div>`,
    data() {
      return {
        output: {},
      }
    },
    methods: {
      tryparse($event) {
        const v = $event.target.value
        $event.target.parentElement.querySelector('pre').innerHTML = Prism.highlight(v, Prism.languages.js, 'js')
        try {
          return this.$emit('expect', JSON.parse(v))
        } catch(e) {
          $event.target.parentElement.className = 'testarea'
        }
      },
    },
    created() {
      let run = 0
      this.$watch(() => [this.setup, this.value, this.expect], async () => {
        if (!this.value || this.expect === undefined) return
        const r = ++run
        const result = await run_test([this.value, this.expect])
        result.success = result.ok
        result.warning = !result.ok && `Expected ${Prism.highlight(Object.prototype.toString.call(result.output).slice(8, -1), Prism.languages.js, 'js')}(${Prism.highlight(JSON.stringify(result.output || null, null, 2), Prism.languages.js, 'js')})<br>to equal ${Prism.highlight(Object.prototype.toString.call(this.expect).slice(8, -1), Prism.languages.js, 'js')}(${Prism.highlight(JSON.stringify(this.expect || null, null, 2), Prism.languages.js, 'js')})`
        this.output = result
      }, { immediate: true })
    },
  })
  new Vue({
    el: 'main',
    data() {
      fetch('/test-unit.js')
        .then(r => r.text())
        .then(eval)
        .then(async () => await run_string(setup.replace(/import (.*);?/, 'await import($1)')))
        .then(() => this.setup = setup)
        .then(() => this.tests = tests)
      return {
        setup: '',
        tests: [],
      }
    },
  })
</script>
